use std::io;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug, Clone)]
struct PostMetadata {
  title: String,
  description: String,
}

impl PostMetadata {
  fn parse(content: &str) -> Option<(PostMetadata, String)> {
    use gray_matter::engine::YAML;
    use gray_matter::Matter;
    let matter = Matter::<YAML>::new();
    // TODO: fork gray_matter and write a version where the returned
    // content is a &str.
    let data = matter.parse_with_struct::<PostMetadata>(content)?;
    Some((data.data, data.content))
  }
}

/// This is the raw html generated by the markdown parser.
#[derive(Debug, Clone)]
pub struct PostContent(String);

impl PostContent {
  pub fn inner_html(self) -> String {
    let PostContent(html) = self;
    html
  }

  fn parse(content: &str) -> Option<PostContent> {
    use pulldown_cmark::{html, Options, Parser};

    let mut options = Options::empty();
    options.insert(Options::ENABLE_HEADING_ATTRIBUTES);

    // In the future I want to do a bunch of customization of the created
    // css.
    let parser = Parser::new_ext(content, options);
    let mut html_output = String::new();
    // TODO: figure out if there are possible errors
    html::push_html(&mut html_output, parser);

    Some(PostContent(html_output))
  }
}

#[derive(Debug, Clone)]
pub struct Post {
  pub title: String,
  pub link_slug: String,
  pub description: String,
  pub content: PostContent,
}

impl Post {
  pub fn parse(slug: String, content: &str) -> Option<Post> {
    let (meta, rest) = PostMetadata::parse(content)?;
    let content = PostContent::parse(&rest)?;
    Some(Post {
      title: meta.title,
      link_slug: slug,
      description: meta.description,
      content,
    })
  }

  pub fn create_href(&self) -> String {
    format!("/blog/{}", &self.link_slug)
  }

/*
  pub async fn parse_in_dir<P: AsRef<async_std::path::Path>>(
    path: P,
  ) -> Result<Vec<Post>, ServerFnError> {
    use async_std::fs::read_dir;
    use futures::future::try_join_all;
    use futures::stream::{StreamExt, TryStreamExt};
    read_dir(path)
      .await?
      .map_err(|err| err.into())
      .and_then(|entry| async move { Post::parse_from(entry.path()).await })
      .try_collect()
      .await
  }
  */
}

pub struct StaticPost {
  pub title: &'static str,
  pub link_slug: &'static str,
  pub description: &'static str,
  pub content: &'static str,
}

impl StaticPost {
  pub fn create_href(&self) -> String {
    format!("/blog/{}", self.link_slug)
  }

  pub fn inner_html(&self) -> &'static str {
    self.content
  }
}
